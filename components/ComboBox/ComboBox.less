/*
   <div class="controls-ComboBox">
      <div class="controls-TextBox__wrapper">
         <span class="controls-ComboBox__fieldNotEditable"> текст </span>
         <input class="controls-ComboBox__field" />
         <div class="controls-ComboBox__Arrow">▼</div>
      </div>
   </div>
 */

/*
   <div class="controls-ComboBox__picker">
      <div class="controls-ComboBox__scrollContainer">
         <div class="controls-ScrollContainer__content">
            <div class="controls-ComboBox__list">
               <div class="controls-ComboBox__item">текст</div>
            </div>
         </div>
      </div>
   </div>
 */

.controls-ComboBox {
   &:hover { //по ховеру на контейнере должен меняться цвет стрелки
      .controls-ComboBox__Arrow {
         color: @color_ComboBox-Arrow_hover;
      }
   }
}

.controls-ComboBox__emptyValue { //TODO: цвет текста летит из текстбокса, поэтому чтобы не завязываться на порядок прилёта CSS-ок придется делать каскад
   .controls-TextBox__field {
      color: @default-placeholder-color;
   }
}

.controls-ComboBox__Arrow {
   //inline-flex, align-items и height нужны для центрирования иконки
   .inline-flexbox();
   .flex-shrink(0);
   .align-items(center);
   .icon-size-without-important(@icon-size_ComboBox-Arrow);
   cursor: pointer;
   padding: 0 0 0 @spacing_ComboBox-Arrow;
   color: @color_ComboBox-Arrow;
}

.controls-ComboBox__Arrow_active {
   color: @color_ComboBox-Arrow_active;
}

.controls-ComboBox__fieldNotEditable {
   display: none;
   white-space: nowrap;
   overflow: hidden;
   .align-self(center);
}

.controls-ComboBox__editable-false {
   .controls-InputRender__field{
      display: none;
   }
   .controls-ComboBox__fieldNotEditable {
      display: inline-block;
      cursor: pointer;
      //Поле ввода нередактируемого комбобокса не должно реагировать на фокус
      &:focus {
         text-overflow: ellipsis;
      }
   }
   .controls-ComboBox__fieldNotEditable__placeholder {
      color: @color_ComboBox_placeholder;
   }
}

//Стили пикера
.controls-ComboBox__picker {
   .box-shadow(@box-shadow_ComboBox_picker);
   background: @background_ComboBox-picker;
   overflow-y: hidden !important; //Если пикер не вмещается в экран, то он навешивает overflow-y: auto. Тут этот скролл не нужен, так что перебиваем его
   border: @border-width_ComboBox-picker solid @border-color_ComboBox-picker;
   color: @color_ComboBox-picker;
   font-size: @font-size_ComboBox-picker;
   box-sizing: border-box;
}

.controls-ComboBox__picker_column_reverse {
   //Чтобы не показывать 2 границы (от комбобокса и от пикера) в настройках пикера стоит offset: -1. Для открытия вниз это работает,
   //а для открытия вверх нужен offset: 1. Переключать offset из комбобокса нереально, т.к. он узнает о том, что пикер открывается вверх
   //уже после расчёта всех отступов. Так что смещаем пикер вниз, если он открывается вверх.
   margin-top: calc(~"1px + "@default-border-width) !important;
   .box-shadow(@box-shadow_ComboBox_picker_revert);
}

.controls-ComboBox__scrollContainer {
   max-height: @max-height_ComboBox-picker; //Для работы ScrollContainer высота должна висеть именно на нем, так что задавать высоту на пикере не получится
   height: 100%; //Нужно в случае, если пикер ограничен высотой окна браузера и на нем висит height, высота скролл-контейнера должна быть не больше высоты родителя
}

.controls-ComboBox__list {
   .flexbox();
}

.controls-ComboBox__list_column {
   .flex-direction(column);
}

.controls-ComboBox__list_column_reverse {
   .flex-direction(column-reverse);
}

.controls-ComboBox__item {
   padding: @padding_ComboBox-item;
   min-height: 21px;
   cursor: pointer;
   &:hover {
      background: @background_ComboBox-item_hover;
   }
}

.controls-ComboBox__item_empty {
   color: @color_ComboBox-item_empty;
}

.controls-ComboBox__item_singleLine {
   .text-overflow();
}

.controls-ComboBox__item_multiLine {
   white-space: normal;
   word-wrap: break-word;
}
