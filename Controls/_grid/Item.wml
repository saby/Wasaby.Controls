<ws:template name="itemActionsTemplateChooser">
   <ws:if data="{{itemData.isSwiped}}">
      <ws:partial template="{{swipeTemplate}}"
                  itemData="{{itemData}}"
                  itemActionsTemplate="{{itemActionsTemplate}}"
                  itemActionsContainerStyles="{{itemActionsContainerStyles}}"
                  highlightOnHover="{{highlightOnHover}}"/>
   </ws:if>
   <ws:else >
      <ws:partial template="{{itemActionsTemplate}}"
                  itemActionsClass="{{itemActionsClass}}"
                  itemData="{{itemData}}"
                  itemActionsContainerStyles="{{itemActionsContainerStyles}}"
                  highlightOnHover="{{highlightOnHover}}"/>
   </ws:else>
</ws:template>
<ws:template name="columnContent">
   <ws:if data="{{itemData.multiSelectVisibility !== 'hidden' && currentColumn.columnIndex === 0}}">
      <ws:partial template="{{multiSelectTpl}}"
                  attr:class="controls-GridView__checkbox {{(itemData.multiSelectVisibility === 'onhover' && itemData.multiSelectStatus === undefined) ? 'controls-GridView__checkbox-onhover'}}">
         <ws:templateOptions multiSelectStatus="{{itemData.multiSelectStatus}}"
                             key="{{itemData.key}}"/>
      </ws:partial>
   </ws:if>
   <ws:else>
      <ws:if data="{{colspan}}">
         <ws:partial template="{{colspanTemplate}}" itemData="{{itemData}}"/>
      </ws:if>
      <ws:else>
         <ws:partial template="{{currentColumn.template}}"
                     ladderWrapper="{{currentColumn.ladderWrapper}}"
                     attr:class="{{currentColumn.column.align ? ' controls-Grid__row-cell__content_halign_' + currentColumn.column.align : ''}}
                     {{itemData.isRightSwiped ? ' controls-ListView__item_rightSwipeAnimation'}}
                     {{currentColumn.column.valign ?' controls-Grid__cell_valign_' + currentColumn.column.valign : ''}}"
                     itemData="{{currentColumn}}"/>
      </ws:else>
   </ws:else>
   <ws:if data="{{itemData.isDrawActions(itemData, currentColumn, colspan)}}">
      <ws:partial template="itemActionsTemplateChooser"/>
   </ws:if>
</ws:template>
<ws:template name="columnContentWrapper">
   <ws:if data="{{marker !== false && itemData.markerVisibility !== 'hidden' && itemData.isSelected && currentColumn.columnIndex === 0}}">
      <div attr:class="controls-GridView__itemV_marker {{itemData.rowSeparatorVisibility ? 'controls-GridView-with-rowSeparator_item_marker' : 'controls-GridView-without-rowSeparator_item_marker'}}"></div>
   </ws:if>
   <ws:partial template="columnContent" attr:class="{{currentColumn.hiddenForLadder ? 'controls-Grid__row-cell__content_hiddenForLadder'}}"/>
</ws:template>
<ws:template name="colTpl">
   <ws:if data="{{!itemData.isNoGridSupport && itemData.columnScroll && itemData.isDrawActions(itemData, currentColumn, colspan)}}">
      <ws:partial template="itemActionsTemplateChooser" itemActionsContainerStyles="{{currentColumn.gridCellStyles}}"/>
   </ws:if>
   <div attr:class="{{currentColumn.cellClasses}}{{!!itemData.isActive && highlightOnHover !== false ? ' controls-GridView__item_active'}}{{!!itemData.isDragging ? ' controls-ListView__item_dragging'}} js-controls-SwipeControl__actionsContainer"
        attr:style="{{itemData.getCellStyle(itemData, currentColumn, colspan, itemData.isNotFullGridSupport) + currentColumn.gridCellStyles}}">
      <ws:partial template="columnContentWrapper"/>
   </div>
</ws:template>
<ws:template name="stickyCell">
   <ws:if data="{{!itemData.isNoGridSupport && itemData.columnScroll && itemData.isDrawActions(itemData, currentColumn, colspan)}}">
      <ws:partial template="itemActionsTemplateChooser" itemActionsContainerStyles="{{itemData.gridCellStyles}}"/>
   </ws:if>
   <Controls.scroll:StickyHeader position="topbottom"
                          attr:class="{{currentColumn.cellClasses}}
                                      {{!!itemData.isActive && highlightOnHover !== false ? ' controls-GridView__item_active'}}
                                      {{!!itemData.isDragging ? ' controls-ListView__item_dragging'}}
                                      js-controls-SwipeControl__actionsContainer"
                          attr:style="{{itemData.getCellStyle(itemData, currentColumn, colspan, itemData.isNotFullGridSupport) + currentColumn.gridCellStyles}}">
      <ws:partial template="columnContentWrapper"/>
   </Controls.scroll:StickyHeader>
</ws:template>

<ws:template name="partialGridSupportItem">

<!-- When using a custom item template, the scope of the base template becomes the same as the scope of custom template.-->
<!-- Because of this, the base handlers are lost.-->
<!-- To fix this, need to remember the handlers where the scope is still right and set them. -->
<!-- But current event system prevent do this, because it looks for given event handler only on closest control (which can -->
<!-- be Browser, Explorer or smth else because of template scope). -->
<!-- Therefore it is required to create Cell as control with and subscribe on events in it. -->
<!-- https://online.sbis.ru/opendoc.html?guid=9d0f8d1a-576d-471d-bf02-991cd02f92e4 -->
<Controls._grid.layouts.partialGridSupport.Cell
        eventHandlers="{{itemData.handlersForPartialSupport}}"
        itemData="{{ itemData }}"
        currentColumn="{{ currentColumn }}"
        currentColumnKey="{{ currentColumnKey }}"
        highlightOnHover="{{ highlightOnHover }}">
   <ws:columnContentTpl>
      <ws:partial template="colTpl" itemData="{{itemData}}" currentColumn="{{currentColumn}}"/>
   </ws:columnContentTpl>
</Controls._grid.layouts.partialGridSupport.Cell>
</ws:template>


<ws:if data="{{itemData.isNoGridSupport}}">
   <tr attr:class="controls-Grid__row controls-ListView__itemV {{highlightOnHover !== false ? 'controls-Grid__row_highlightOnHover_' + (itemData.style || 'default')}} controls-Grid__row_{{itemData.style || 'default'}}">
      <ws:for data="itemData.resetColumnIndex(); itemData.getLastColumnIndex()>=itemData.columnIndex && (!colspan || itemData.columnIndex<(itemData.multiSelectVisibility === 'hidden' ? 1 : 0)); itemData.goToNextColumn();">
         <td attr:class="{{itemData.getCurrentColumn().cellClasses}}{{!!itemData.isActive && highlightOnHover !== false ? ' controls-GridView__item_active'}}{{!!itemData.isDragging ? ' controls-ListView__item_dragging'}} js-controls-SwipeControl__actionsContainer
                         {{(marker !== false && itemData.markerVisibility !== 'hidden' && itemData.isSelected && itemData.columnIndex === 0)?' controls-Grid__row-cell_selected__first'}}"
             attr:key="{{itemData.getCurrentColumnKey()}}"
             attr:style="{{itemData.getCellStyle(itemData, itemData.getCurrentColumn(), colspan, itemData.isNotFullGridSupport)}}">
            <ws:partial template="columnContent" currentColumn="{{itemData.getCurrentColumn()}}" attr:class="{{itemData.getCurrentColumn().hiddenForLadder ? 'controls-Grid__row-cell__content_hiddenForLadder'}}"/>
         </td>
      </ws:for>
   </tr>
</ws:if>
<ws:else data="{{itemData.isPartialGridSupport}}">

   <ws:if data="{{itemData.styleLadderHeading}}">
      <div attr:class="controls-Grid__row-ladder-cell {{itemData.getItemColumnCellClasses(itemData)}}{{!!itemData.isActive ? ' controls-GridView__item_active'}}{{!!itemData.isDragging ? ' controls-ListView__item_dragging'}} js-controls-SwipeControl__actionsContainer"
           attr:style="{{itemData.styleLadderHeading}}">
         <ws:partial template="columnContent" currentColumn="{{itemData.getCurrentColumn()}}" attr:class="controls-Grid__row-ladder-cell__content"/>
      </div>
   </ws:if>

   <!-- Строка в режиме редактирования  -->
   <ws:if data="{{itemData.isEditing}}">
      <div attr:style="{{itemData.editingRowStyles}}">
         <ws:for data="itemData.resetColumnIndex(); itemData.getLastColumnIndex()>=itemData.columnIndex && (!colspan || itemData.columnIndex<(itemData.multiSelectVisibility === 'hidden' ? 1 : 0)); itemData.goToNextColumn();">
            <!-- To avoid closures, need to give all generating in itemData as a template options. -->
            <!-- For-loop creates it's own scope. In for scope itemData is always the same object. -->
            <!-- The template engine first builds the first level templates located in the body of the loop and does not enter them. -->             <!-- Then it begins to build sub templates, for-iteration has been ended, so iterator will always give last column. -->
            <ws:partial template="partialGridSupportItem"
                        currentColumn="{{itemData.getCurrentColumn()}}"
                        currentColumnKey="{{itemData.getCurrentColumnKey()}}"
                        itemData="{{itemData}}"
                        highlightOnHover="{{highlightOnHover}}"/>
         </ws:for>
      </div>
   </ws:if>

   <!-- Строка в режиме просмотра -->
   <ws:else>
      <ws:for data="itemData.resetColumnIndex(); itemData.getLastColumnIndex()>=itemData.columnIndex && (!colspan || itemData.columnIndex<(itemData.multiSelectVisibility === 'hidden' ? 1 : 0)); itemData.goToNextColumn();">
         <!-- To avoid closures, need to give all generating in itemData as a template options. -->
         <!-- For-loop creates it's own scope. In for scope itemData is always the same object. -->
         <!-- The template engine first builds the first level templates located in the body of the loop and does not enter them. -->
         <ws:partial
                 template="partialGridSupportItem"
                 currentColumn="{{itemData.getCurrentColumn()}}"
                 currentColumnKey="{{itemData.getCurrentColumnKey()}}"
                 itemData="{{itemData}}"
                 highlightOnHover="{{highlightOnHover}}" />
      </ws:for>
   </ws:else>

</ws:else>
<ws:else>
   <ws:if data="{{itemData.styleLadderHeading}}">
      <div attr:class="controls-Grid__row-ladder-cell {{itemData.getItemColumnCellClasses(itemData)}}{{!!itemData.isActive ? ' controls-GridView__item_active'}}{{!!itemData.isDragging ? ' controls-ListView__item_dragging'}} js-controls-SwipeControl__actionsContainer"
           attr:style="{{itemData.styleLadderHeading}}">
         <ws:partial template="columnContent" currentColumn="{{itemData.getCurrentColumn()}}" attr:class="controls-Grid__row-ladder-cell__content"/>
      </div>
   </ws:if>
   <ws:if data="{{itemData.isSticky}}">
      <Controls.scroll:Group>
         <div attr:class="controls-Grid__row controls-ListView__itemV {{highlightOnHover !== false ? 'controls-Grid__row_highlightOnHover_' + (itemData.style || 'default')}} controls-Grid__row_{{itemData.style || 'default'}}">
            <!-- The iterator does not restart when the model changes. Instead, the internal partial is redrawn. We do a reboot forcibly. -->
            <!-- Delete after the task is done https://online.sbis.ru/opendoc.html?guid=13786a2a-54c7-4a09-8fbc-11344cf0804d -->
            {{itemData.resetColumnIndex()}}
            <ws:for data="itemData.resetColumnIndex(); itemData.getLastColumnIndex()>=itemData.columnIndex && (!colspan || itemData.columnIndex<(itemData.multiSelectVisibility === 'hidden' ? 1 : 0)); itemData.goToNextColumn();">
               <ws:partial template="stickyCell" attr:key="{{itemData.getCurrentColumnKey()}}" currentColumn="{{itemData.getCurrentColumn()}}"/>
            </ws:for>
         </div>
      </Controls.scroll:Group>
   </ws:if>
   <ws:else>
      <div attr:class="controls-Grid__row controls-ListView__itemV {{highlightOnHover !== false ? 'controls-Grid__row_highlightOnHover_' + (itemData.style || 'default')}} controls-Grid__row_{{itemData.style || 'default'}}">
         <ws:for data="itemData.resetColumnIndex(); itemData.getLastColumnIndex()>=itemData.columnIndex && (!colspan || itemData.columnIndex<(itemData.multiSelectVisibility === 'hidden' ? 1 : 0)); itemData.goToNextColumn();">
            <ws:partial template="colTpl" attr:key="{{itemData.getCurrentColumnKey()}}" currentColumn="{{itemData.getCurrentColumn()}}"/>
         </ws:for>
      </div>
   </ws:else>
</ws:else>
